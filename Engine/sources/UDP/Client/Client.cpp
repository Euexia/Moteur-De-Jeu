//#include "UDP/Client/Client.h"
//
//namespace Network
//{
//	namespace UDP
//	{
//		bool ConnectionHandlerUDP::connect(SOCKET sckt, const std::string& address, unsigned short port)
//		{
//			assert(sckt != INVALID_SOCKET);
//			mAddress = address;
//			mPort = port;
//			// permet d'écouter les différents événements ( voir en dessous le Message::Connection )
//			mFd.fd = sckt;
//			// de base POLLOUT - il vérifiera si le descripteur de fichier est prêt à écrire.
//			mFd.events = POLLOUT;
//			inet_pton(AF_INET, mAddress.c_str(), &mConnectedAddress.sin_addr.s_addr);
//			mConnectedAddress.sin_family = AF_INET;
//			mConnectedAddress.sin_port = htons(mPort);
//			// tente de ce connecter au serveur distant
//			if (::connect(sckt, (const sockaddr*)&mConnectedAddress, sizeof(mConnectedAddress)) != 0)
//			{
//				int err = Errors::Get();
//				if (err != Errors::INPROGRESS && err != Errors::WOULDBLOCK)
//					return false;
//			}
//			return true;
//		}
//		// Nous utilisons "poll()" pour ne pas bloquer le programme quand une opération UDP est en cours
//		std::unique_ptr<Messages::Connection> ConnectionHandlerUDP::poll()
//		{
//			int res = ::poll(&mFd, 1, 0);
//			if (res < 0)
//				return std::make_unique<Messages::Connection>(Messages::Connection::Result::Failed);
//			else if (res > 0)
//			{
//				// Descripteur de fichier permet d'identifier de manière unique chaque fichier ouvert
//				if (mFd.revents & POLLOUT)
//				{
//					// Descripteur de fichier est prêt à être écrit
//					return std::make_unique<Messages::Connection>(Messages::Connection::Result::Success);
//				}
//				else if (mFd.revents & (POLLHUP | POLLNVAL))
//				{
//					// Fin de connexion ou descripteur de fichier invalide
//					return std::make_unique<Messages::Connection>(Messages::Connection::Result::Failed);
//				}
//				else if (mFd.revents & POLLERR)
//				{
//					// Erreur sur le descripteur de fichier
//					return std::make_unique<Messages::Connection>(Messages::Connection::Result::Failed);
//				}
//			}
//			//!< action non terminée
//			return nullptr;
//		}
//
//		void ReceptionHandlerUDP::init(SOCKET sckt)
//		{
//			assert(sckt != INVALID_SOCKET);
//			mSckt = sckt;
//			startHeaderReception();
//		}
//		// init la récéption du Header ( l'en-tête ) en prenant compte de sa taille
//		void ReceptionHandlerUDP::startHeaderReception()
//		{
//			startReception(HeaderSize, State::Header);
//		}
//		// fonction appellée une fois que qu'elle à reçu le Header complet
//		void ReceptionHandlerUDP::startDataReception()
//		{
//			assert(mBuffer.size() == sizeof(HeaderType));
//			HeaderType networkExpectedDataLength;
//			memcpy(&networkExpectedDataLength, mBuffer.data(), sizeof(networkExpectedDataLength));
//			const auto expectedDataLength = ntohs(networkExpectedDataLength);
//			startReception(expectedDataLength, State::Data);
//		}
//		void ReceptionHandlerUDP::startReception(unsigned int expectedDataLength, State newState)
//		{
//			mReceived = 0;
//			mBuffer.clear();
//			mBuffer.resize(expectedDataLength, 0);
//			mState = newState;
//		}
//		std::unique_ptr<Messages::Base> ReceptionHandlerUDP::recvfrom()
//		{
//			assert(mSckt != INVALID_SOCKET);
//
//			sockaddr_in senderAddr;
//			int senderAddrSize = sizeof(senderAddr);
//			int ret = ::recvfrom(mSckt, missingDataStartBuffer(), missingDataLength(), 0, reinterpret_cast<sockaddr*>(&senderAddr), &senderAddrSize);
//			if (ret > 0)
//			{
//				mReceived += ret;
//				if (mReceived == mBuffer.size())
//				{
//					if (mState == State::Data)
//					{
//						// si toutes les données attendues sont arrivées alors elle renvoie "Messages::UserData"
//						std::unique_ptr<Messages::Base> msg = std::make_unique<Messages::UserData>(std::move(mBuffer));
//						startHeaderReception();
//						return msg;
//					}
//					else
//					{
//						startDataReception();
//						//!< si jamais les données sont déjà disponibles elles seront ainsi retournées directement
//						return recvfrom();
//					}
//				}
//				return nullptr;
//			}
//			else if (ret == 0)
//			{
//				//!< connexion terminée correctement
//				return std::make_unique<Messages::Disconnection>(Messages::Disconnection::Reason::Disconnected);
//			}
//			else // ret < 0
//			{
//				//!< traitement d'erreur
//				int error = Errors::Get();
//				if (error == Errors::WOULDBLOCK || error == Errors::AGAIN)
//				{
//					return nullptr;
//				}
//				else
//				{
//					return std::make_unique<Messages::Disconnection>(Messages::Disconnection::Reason::Lost);
//				}
//			}
//		}
//		
//		void SendingHandlerUDP::init(SOCKET sckt)
//		{
//			mSocket = sckt;
//			if (mState == State::Header || mState == State::Data)
//			{
//				// nettoie le tampon d'envoie
//				mSendingBuffer.clear();
//			}
//			mState = State::Idle;
//		}
//
//		// permet de mettre des données dans la file d'attente pour l'envoie
//		bool SendingHandlerUDP::sendto(const unsigned char* data, unsigned int datalen)
//		{
//			if (datalen > std::numeric_limits<HeaderType>::max())
//			{
//				return false;
//			}
//			mQueueingBuffers.emplace_back(data, data + datalen);
//			return true;
//		}
//
//		// permet de gérer l'envoie de données
//		void SendingHandlerUDP::update()
//		{
//			assert(mSocket != INVALID_SOCKET);
//			if (mState == State::Idle && !mQueueingBuffers.empty())
//			{
//				// si il y a des données en attente, elle prépare l'envoie du prochain en-tête
//				prepareNextHeader();
//			}
//			// tant on peut envoyer des données
//			while (mState != State::Idle && sendPendingBuffer())
//			{
//				if (mState == State::Header)
//				{
//					prepareNextData();
//				}
//				else
//				{
//					if (!mQueueingBuffers.empty())
//					{
//						prepareNextHeader();
//					}
//					else
//					{
//						mState = State::Idle;
//					}
//				}
//			}
//		}
//
//		// permet d'envoyer des données qui sont en attente sur le socket
//		bool SendingHandlerUDP::sendPendingBuffer()
//		{
//			if (mSendingBuffer.empty())
//			{
//				return true;
//			}
//
//			//!< envoi des données restantes du dernier envoi
//			int sent = ::sendto(mSocket, reinterpret_cast<char*>(mSendingBuffer.data()), static_cast<int>(mSendingBuffer.size()), 0, nullptr, 0);
//			if (sent > 0)
//			{
//				if (sent == mSendingBuffer.size())
//				{
//					//!< toutes les données ont été envoyées
//					mSendingBuffer.clear();
//					return true;
//				}
//				else
//				{
//					//!< envoi partiel
//					memmove(mSendingBuffer.data() + sent, mSendingBuffer.data(), sent);
//					mSendingBuffer.erase(mSendingBuffer.cbegin() + sent, mSendingBuffer.cend());
//				}
//			}
//			return false;
//		}
//
//		// prépare l'envoie de la prochaine en-tête
//		void SendingHandlerUDP::prepareNextHeader()
//		{
//			assert(!mQueueingBuffers.empty());
//			const auto header = static_cast<HeaderType>(mQueueingBuffers.front().size());
//			const auto networkHeader = htons(header);
//			mSendingBuffer.clear();
//			mSendingBuffer.resize(HeaderSize);
//			memcpy(mSendingBuffer.data(), &networkHeader, sizeof(HeaderType));
//			mState = State::Header;
//		}
//		
//		// prépare l'envoie des prochaines données
//		void SendingHandlerUDP::prepareNextData()
//		{
//			assert(!mQueueingBuffers.empty());
//			mSendingBuffer.swap(mQueueingBuffers.front());
//			mQueueingBuffers.pop_front();
//			mState = State::Data;
//		}
//
//		// permet de calculer la taille total des données en attente
//		size_t SendingHandlerUDP::queueSize() const
//		{
//			size_t s = std::accumulate(mQueueingBuffers.cbegin(), mQueueingBuffers.cend(), static_cast<size_t>(0), [](size_t n, const std::vector<unsigned char>& queuedItem) {
//				return n + queuedItem.size() + HeaderSize;
//				});
//			if (mState == State::Data)
//				s += mSendingBuffer.size();
//			return s;
//		}
//
//		ClientImplUDP::~ClientImplUDP()
//		{
//			disconnect();
//		}
//
//		bool ClientImplUDP::init(SOCKET&& sckt, const sockaddr_in& addr)
//		{
//			assert(sckt != INVALID_SOCKET);
//			if (sckt == INVALID_SOCKET)
//				return false;
//
//			assert(mState == State::Disconnected);
//			assert(mSocket == INVALID_SOCKET);
//			if (mSocket != INVALID_SOCKET)
//				disconnect();
//
//			mSocket = sckt;
//			if (!SetNonBlocking(mSocket))
//			{
//				disconnect();
//				return false;
//			}
//			onConnected(addr);
//			return true;
//		}
//
//		bool ClientImplUDP::connect(const std::string& ipaddress, unsigned short port)
//		{
//			assert(mState == State::Disconnected);
//			assert(mSocket == INVALID_SOCKET);
//			if (mSocket != INVALID_SOCKET)
//			{
//				disconnect();
//			}
//			mSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
//			if (mSocket == INVALID_SOCKET)
//			{
//				return false;
//			}
//			else if (!SetNonBlocking(mSocket))
//			{
//				disconnect();
//				return false;
//			}
//			if (mConnectionHandler.connect(mSocket, ipaddress, port))
//			{
//				mState = State::Connecting;
//				return true;
//			}
//			return false;
//		}
//
//		void ClientImplUDP::disconnect()
//		{
//			if (mSocket != INVALID_SOCKET)
//			{
//				CloseSocket(mSocket);
//			}
//			mSocket = INVALID_SOCKET;
//			mState = State::Disconnected;
//		}
//
//		bool ClientImplUDP::sendto(const unsigned char* data, unsigned int len)
//		{
//			return mSendingHandler.sendto(data, len);
//		}
//
//		std::unique_ptr<Messages::Base> ClientImplUDP::poll()
//		{
//			switch (mState)
//			{
//			// check si le client ce connecte
//			case State::Connecting:
//			{
//				// si il ce connecte alors "mConnectionHandler.poll()" vérifie l'état de la connexion qui est en cours
//				auto msg = mConnectionHandler.poll();
//				if (msg)
//				{
//					// connexion réussite
//					if (msg->result == Messages::Connection::Result::Success)
//					{
//						onConnected(mConnectionHandler.connectedAddress());
//					}
//					else
//					{
//						// fermer la connexion car il y a eu une erreur
//						disconnect();
//					}
//				}
//				// on return quand même le message
//				return msg;
//			} break;
//			// le client est déjà connecté
//			case State::Connected:
//			{
//				// appelle "update" pour envoyer les données en attente
//				mSendingHandler.update();
//				// recvfrom qui sert à recevoir les messages entrant
//				auto msg = mReceivingHandler.recvfrom();
//				if (msg)
//				{
//					if (msg->is<Messages::Disconnection>())
//					{
//						disconnect();
//					}
//				}
//				return msg;
//			} break;
//			case State::Disconnected:
//			{
//			} break;
//			}
//			return nullptr;
//		}
//
//		// connexion réussie, init de l'adresse du serveur + l'init des gestionnaires d'envoi et de réception
//		void ClientImplUDP::onConnected(const sockaddr_in& addr)
//		{
//			mAddress = addr;
//			mSendingHandler.init(mSocket);
//			mReceivingHandler.init(mSocket);
//			mState = State::Connected;
//		}
//
//		// constructeur de déplacement & opérateur d'affectation de déplacement
//		// Ils s'occupent de transferer les ressources ( mImpl ) de l'objet source vers l'objet this
//		// Utilisation de std::move() pour éviter les copies coûteuses
//		ClientUDP::ClientUDP(ClientUDP&& other)
//			: mImpl(std::move(other.mImpl))
//		{}
//		ClientUDP& ClientUDP::operator=(ClientUDP&& other)
//		{
//			mImpl = std::move(other.mImpl);
//			return *this;
//		}
//
//		// init permet d'initialiser une connexion à un serveur distant
//		bool ClientUDP::init(SOCKET&& sckt, const sockaddr_in& addr)
//		{
//			if (!mImpl)
//				mImpl = std::make_unique<ClientImplUDP>();
//			return mImpl && mImpl->init(std::move(sckt), addr);
//		}
//
//		// connect permet d'établir la connexion à un serveur distant
//		bool ClientUDP::connect(const std::string& ipaddress, unsigned short port)
//		{
//			if (!mImpl)
//				mImpl = std::make_unique<ClientImplUDP>();
//			return mImpl && mImpl->connect(ipaddress, port);
//		}
//
//		// disconnect permet de fermer la connexion avec le serveur distant
//		void ClientUDP::disconnect() { if (mImpl) mImpl->disconnect(); mImpl = nullptr; }
//
//		// send permet d'envoyer des données au serveur distant grâce à la connexion établie
//		bool ClientUDP::sendto(const unsigned char* data, unsigned int len) { return mImpl && mImpl->sendto(data, len); }
//
//		// poll permet de vérifier si les données venant du serveur distant sont disponibles à recevoir
//		// Renvoie "Messages::Base" pour déterminer le messages à transmettre
//		std::unique_ptr<Messages::Base> ClientUDP::poll() { return mImpl ? mImpl->poll() : nullptr; }
//
//		//permet d'obtenir l'id du client et l'adresse de destination associée à la connexion
//		uint64_t ClientUDP::id() const { return mImpl ? mImpl->id() : -1; }
//		const sockaddr_in& ClientUDP::destinationAddress() const { static sockaddr_in empty{ 0 }; return mImpl ? mImpl->destinationAddress() : empty; }
//	}
//}