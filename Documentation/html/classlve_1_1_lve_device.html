<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>An-Gine: RÃ©fÃ©rence de la classe lve::LveDevice</title>
<link rel="icon" href="An-Gine.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="An-Gine.png"/></td>
  <td id="projectalign">
   <div id="projectname">An-Gine<span id="projectnumber">&#160;0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- GÃ©nÃ©rÃ© par Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Recherche');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Chargement...</div>
<div class="SRStatus" id="Searching">Recherche...</div>
<div class="SRStatus" id="NoMatches">Aucune correspondance</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>lve</b></li><li class="navelem"><a class="el" href="classlve_1_1_lve_device.html">LveDevice</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Fonctions membres publiques</a> &#124;
<a href="#pub-attribs">Attributs publics</a> &#124;
<a href="classlve_1_1_lve_device-members.html">Liste de tous les membres</a>  </div>
  <div class="headertitle"><div class="title">RÃ©fÃ©rence de la classe lve::LveDevice</div></div>
</div><!--header-->
<div class="contents">

<p>Classe représentant un périphérique Vulkan.  
 <a href="#details">Plus de dÃ©tails...</a></p>

<p><code>#include &lt;<a class="el" href="lve__device_8h_source.html">lve_device.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Fonctions membres publiques</h2></td></tr>
<tr class="memitem:a5dbf67e8518005fdcd3de7113272f6cc" id="r_a5dbf67e8518005fdcd3de7113272f6cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dbf67e8518005fdcd3de7113272f6cc">LveDevice</a> (<a class="el" href="class_window_module.html">WindowModule</a> *_windowModule)</td></tr>
<tr class="memdesc:a5dbf67e8518005fdcd3de7113272f6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur de la classe <a class="el" href="classlve_1_1_lve_device.html" title="Classe représentant un périphérique Vulkan.">LveDevice</a>.  <br /></td></tr>
<tr class="separator:a5dbf67e8518005fdcd3de7113272f6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3928e5409dc9c8e054d06270a56c9d93" id="r_a3928e5409dc9c8e054d06270a56c9d93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3928e5409dc9c8e054d06270a56c9d93">~LveDevice</a> ()</td></tr>
<tr class="memdesc:a3928e5409dc9c8e054d06270a56c9d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructeur de la classe <a class="el" href="classlve_1_1_lve_device.html" title="Classe représentant un périphérique Vulkan.">LveDevice</a>.  <br /></td></tr>
<tr class="separator:a3928e5409dc9c8e054d06270a56c9d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0d35625590c8930b8045383c06a495" id="r_acd0d35625590c8930b8045383c06a495"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd0d35625590c8930b8045383c06a495">LveDevice</a> (const <a class="el" href="classlve_1_1_lve_device.html">LveDevice</a> &amp;)=delete</td></tr>
<tr class="memdesc:acd0d35625590c8930b8045383c06a495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur de copie supprimé.  <br /></td></tr>
<tr class="separator:acd0d35625590c8930b8045383c06a495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab611df790f3cc5fc5719d2d90578ecf" id="r_aab611df790f3cc5fc5719d2d90578ecf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlve_1_1_lve_device.html">LveDevice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab611df790f3cc5fc5719d2d90578ecf">operator=</a> (const <a class="el" href="classlve_1_1_lve_device.html">LveDevice</a> &amp;)=delete</td></tr>
<tr class="memdesc:aab611df790f3cc5fc5719d2d90578ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opérateur d'affectation de copie supprimé.  <br /></td></tr>
<tr class="separator:aab611df790f3cc5fc5719d2d90578ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec8815791e048ac42a73fcbfe1b154a" id="r_a2ec8815791e048ac42a73fcbfe1b154a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ec8815791e048ac42a73fcbfe1b154a">LveDevice</a> (<a class="el" href="classlve_1_1_lve_device.html">LveDevice</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a2ec8815791e048ac42a73fcbfe1b154a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur de déplacement supprimé.  <br /></td></tr>
<tr class="separator:a2ec8815791e048ac42a73fcbfe1b154a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7c2ce480c9381910528bb05ef68f70" id="r_a0a7c2ce480c9381910528bb05ef68f70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlve_1_1_lve_device.html">LveDevice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a7c2ce480c9381910528bb05ef68f70">operator=</a> (<a class="el" href="classlve_1_1_lve_device.html">LveDevice</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a0a7c2ce480c9381910528bb05ef68f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opérateur d'affectation de déplacement supprimé.  <br /></td></tr>
<tr class="separator:a0a7c2ce480c9381910528bb05ef68f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34aae465d220806aacc3322242696d1d" id="r_a34aae465d220806aacc3322242696d1d"><td class="memItemLeft" align="right" valign="top">vk::CommandPool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34aae465d220806aacc3322242696d1d">GetCommandPool</a> () const</td></tr>
<tr class="memdesc:a34aae465d220806aacc3322242696d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Récupère le pool de commandes Vulkan associé au périphérique.  <br /></td></tr>
<tr class="separator:a34aae465d220806aacc3322242696d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4755528cbaa93add122a7edbf464845" id="r_ab4755528cbaa93add122a7edbf464845"><td class="memItemLeft" align="right" valign="top">vk::Device&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4755528cbaa93add122a7edbf464845">Device</a> () const</td></tr>
<tr class="memdesc:ab4755528cbaa93add122a7edbf464845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Récupère l'objet de périphérique Vulkan.  <br /></td></tr>
<tr class="separator:ab4755528cbaa93add122a7edbf464845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efae05c0dda3dcd86e7bcd3eec740c8" id="r_a7efae05c0dda3dcd86e7bcd3eec740c8"><td class="memItemLeft" align="right" valign="top"><a id="a7efae05c0dda3dcd86e7bcd3eec740c8" name="a7efae05c0dda3dcd86e7bcd3eec740c8"></a>
vk::Instance&#160;</td><td class="memItemRight" valign="bottom"><b>GetInstance</b> () const</td></tr>
<tr class="separator:a7efae05c0dda3dcd86e7bcd3eec740c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa748de1ca493fac23099635dcb5a6b19" id="r_aa748de1ca493fac23099635dcb5a6b19"><td class="memItemLeft" align="right" valign="top"><a id="aa748de1ca493fac23099635dcb5a6b19" name="aa748de1ca493fac23099635dcb5a6b19"></a>
vk::PhysicalDevice&#160;</td><td class="memItemRight" valign="bottom"><b>GetPhysicalDevice</b> () const</td></tr>
<tr class="separator:aa748de1ca493fac23099635dcb5a6b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e39fcb2417fc88244a2bd7b47fda216" id="r_a4e39fcb2417fc88244a2bd7b47fda216"><td class="memItemLeft" align="right" valign="top">vk::SurfaceKHR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e39fcb2417fc88244a2bd7b47fda216">Surface</a> () const</td></tr>
<tr class="memdesc:a4e39fcb2417fc88244a2bd7b47fda216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Récupère la surface Vulkan associée au périphérique.  <br /></td></tr>
<tr class="separator:a4e39fcb2417fc88244a2bd7b47fda216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db7cac38a972c8794d8cb209a784231" id="r_a3db7cac38a972c8794d8cb209a784231"><td class="memItemLeft" align="right" valign="top">vk::Queue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3db7cac38a972c8794d8cb209a784231">GraphicsQueue</a> () const</td></tr>
<tr class="memdesc:a3db7cac38a972c8794d8cb209a784231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Récupère la file de commandes graphiques du périphérique.  <br /></td></tr>
<tr class="separator:a3db7cac38a972c8794d8cb209a784231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880570c94a1582853d2301af3c88e104" id="r_a880570c94a1582853d2301af3c88e104"><td class="memItemLeft" align="right" valign="top">vk::Queue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a880570c94a1582853d2301af3c88e104">PresentQueue</a> () const</td></tr>
<tr class="memdesc:a880570c94a1582853d2301af3c88e104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Récupère la file de commandes de présentation du périphérique.  <br /></td></tr>
<tr class="separator:a880570c94a1582853d2301af3c88e104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705e5ae87f7a4885b8f4a115694076a5" id="r_a705e5ae87f7a4885b8f4a115694076a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlve_1_1_swap_chain_support_details.html">SwapChainSupportDetails</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a705e5ae87f7a4885b8f4a115694076a5">GetSwapChainSupport</a> ()</td></tr>
<tr class="memdesc:a705e5ae87f7a4885b8f4a115694076a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Récupère les détails de prise en charge de la chaîne de balisage pour le périphérique.  <br /></td></tr>
<tr class="separator:a705e5ae87f7a4885b8f4a115694076a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84495cbcca8e67db53fc15d6ab5a6847" id="r_a84495cbcca8e67db53fc15d6ab5a6847"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84495cbcca8e67db53fc15d6ab5a6847">FindMemoryType</a> (uint32_t _typeFilter, vk::MemoryPropertyFlags _properties) const</td></tr>
<tr class="memdesc:a84495cbcca8e67db53fc15d6ab5a6847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trouve un type de mémoire approprié pour une utilisation spécifiée.  <br /></td></tr>
<tr class="separator:a84495cbcca8e67db53fc15d6ab5a6847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b015567e250ee4f37aac78a940620a" id="r_aa1b015567e250ee4f37aac78a940620a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlve_1_1_queue_family_indices.html">QueueFamilyIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1b015567e250ee4f37aac78a940620a">FindPhysicalQueueFamilies</a> () const</td></tr>
<tr class="memdesc:aa1b015567e250ee4f37aac78a940620a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trouve les familles de files de commandes physiques disponibles sur le périphérique.  <br /></td></tr>
<tr class="separator:aa1b015567e250ee4f37aac78a940620a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a393668b4b4c5aa202ea41168dc16e" id="r_a20a393668b4b4c5aa202ea41168dc16e"><td class="memItemLeft" align="right" valign="top">vk::Format&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20a393668b4b4c5aa202ea41168dc16e">FindSupportedFormat</a> (const std::vector&lt; vk::Format &gt; &amp;_candidates, vk::ImageTiling _tiling, vk::FormatFeatureFlags _features) const</td></tr>
<tr class="memdesc:a20a393668b4b4c5aa202ea41168dc16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trouve un format d'image supporté par le périphérique.  <br /></td></tr>
<tr class="separator:a20a393668b4b4c5aa202ea41168dc16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170e75725fcef0f1c461651a139bb8ce" id="r_a170e75725fcef0f1c461651a139bb8ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a170e75725fcef0f1c461651a139bb8ce">CreateBuffer</a> (vk::DeviceSize _size, vk::BufferUsageFlags _usage, vk::MemoryPropertyFlags _properties, vk::Buffer &amp;_buffer, vk::DeviceMemory &amp;_bufferMemory) const</td></tr>
<tr class="memdesc:a170e75725fcef0f1c461651a139bb8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crée un tampon Vulkan avec les paramètres spécifiés.  <br /></td></tr>
<tr class="separator:a170e75725fcef0f1c461651a139bb8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cb21509496085180d25539f12c6e0f" id="r_a70cb21509496085180d25539f12c6e0f"><td class="memItemLeft" align="right" valign="top">vk::CommandBuffer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70cb21509496085180d25539f12c6e0f">BeginSingleTimeCommands</a> () const</td></tr>
<tr class="memdesc:a70cb21509496085180d25539f12c6e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Démarre une séquence de commandes Vulkan temporaires.  <br /></td></tr>
<tr class="separator:a70cb21509496085180d25539f12c6e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3f80b67ef6cbd66e48490e5396fd13" id="r_a1e3f80b67ef6cbd66e48490e5396fd13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e3f80b67ef6cbd66e48490e5396fd13">EndSingleTimeCommands</a> (vk::CommandBuffer _commandBuffer) const</td></tr>
<tr class="memdesc:a1e3f80b67ef6cbd66e48490e5396fd13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Termine une séquence de commandes Vulkan temporaires.  <br /></td></tr>
<tr class="separator:a1e3f80b67ef6cbd66e48490e5396fd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e53a2d80e60f69d69882e65429924b" id="r_a15e53a2d80e60f69d69882e65429924b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15e53a2d80e60f69d69882e65429924b">CopyBuffer</a> (vk::Buffer _srcBuffer, vk::Buffer _dstBuffer, vk::DeviceSize _size) const</td></tr>
<tr class="memdesc:a15e53a2d80e60f69d69882e65429924b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copie les données d'un tampon source vers un tampon de destination.  <br /></td></tr>
<tr class="separator:a15e53a2d80e60f69d69882e65429924b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada99e3ebd5a9f7b3df3840e97fa91f78" id="r_ada99e3ebd5a9f7b3df3840e97fa91f78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada99e3ebd5a9f7b3df3840e97fa91f78">CopyBufferToImage</a> (vk::Buffer _buffer, vk::Image _image, uint32_t _width, uint32_t _height, uint32_t _layerCount) const</td></tr>
<tr class="memdesc:ada99e3ebd5a9f7b3df3840e97fa91f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copie les données d'un tampon vers une image Vulkan.  <br /></td></tr>
<tr class="separator:ada99e3ebd5a9f7b3df3840e97fa91f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0556bd5de6d7e04cd817ce000c64f1d" id="r_af0556bd5de6d7e04cd817ce000c64f1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0556bd5de6d7e04cd817ce000c64f1d">CreateImageWithInfo</a> (const vk::ImageCreateInfo &amp;_imageInfo, vk::MemoryPropertyFlags _properties, vk::Image &amp;_image, vk::DeviceMemory &amp;_imageMemory) const</td></tr>
<tr class="memdesc:af0556bd5de6d7e04cd817ce000c64f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crée une image Vulkan avec les informations fournies.  <br /></td></tr>
<tr class="separator:af0556bd5de6d7e04cd817ce000c64f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d82b4686e1e0ca2e3ca7143fd56865" id="r_a11d82b4686e1e0ca2e3ca7143fd56865"><td class="memItemLeft" align="right" valign="top">vk::Instance&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11d82b4686e1e0ca2e3ca7143fd56865">CreateInstance</a> ()</td></tr>
<tr class="memdesc:a11d82b4686e1e0ca2e3ca7143fd56865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crée une instance Vulkan.  <br /></td></tr>
<tr class="separator:a11d82b4686e1e0ca2e3ca7143fd56865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8aa1272efa148228a786f43eee2605" id="r_a5c8aa1272efa148228a786f43eee2605"><td class="memItemLeft" align="right" valign="top">vk::DebugUtilsMessengerEXT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c8aa1272efa148228a786f43eee2605">SetupDebugMessenger</a> ()</td></tr>
<tr class="memdesc:a5c8aa1272efa148228a786f43eee2605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure le gestionnaire de débogage.  <br /></td></tr>
<tr class="separator:a5c8aa1272efa148228a786f43eee2605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ab9abde3ae4c6ed01a8723e6695251" id="r_ae5ab9abde3ae4c6ed01a8723e6695251"><td class="memItemLeft" align="right" valign="top"><a id="ae5ab9abde3ae4c6ed01a8723e6695251" name="ae5ab9abde3ae4c6ed01a8723e6695251"></a>
vk::DebugUtilsMessengerEXT&#160;</td><td class="memItemRight" valign="bottom"><b>GetDebugMessenger</b> () const</td></tr>
<tr class="separator:ae5ab9abde3ae4c6ed01a8723e6695251"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Attributs publics</h2></td></tr>
<tr class="memitem:a3c4169c2199d569b4e16f57b7a898db8" id="r_a3c4169c2199d569b4e16f57b7a898db8"><td class="memItemLeft" align="right" valign="top"><a id="a3c4169c2199d569b4e16f57b7a898db8" name="a3c4169c2199d569b4e16f57b7a898db8"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>enableValidationLayers</b> = true</td></tr>
<tr class="separator:a3c4169c2199d569b4e16f57b7a898db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee7068dc3c270e771cf87b14da36bff" id="r_a1ee7068dc3c270e771cf87b14da36bff"><td class="memItemLeft" align="right" valign="top">vk::PhysicalDeviceProperties&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ee7068dc3c270e771cf87b14da36bff">properties</a></td></tr>
<tr class="memdesc:a1ee7068dc3c270e771cf87b14da36bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propriétés du périphérique physique Vulkan associé.  <br /></td></tr>
<tr class="separator:a1ee7068dc3c270e771cf87b14da36bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description dÃ©taillÃ©e</h2>
<div class="textblock"><p>Classe représentant un périphérique Vulkan. </p>
</div><h2 class="groupheader">Documentation des constructeurs et destructeur</h2>
<a id="a5dbf67e8518005fdcd3de7113272f6cc" name="a5dbf67e8518005fdcd3de7113272f6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbf67e8518005fdcd3de7113272f6cc">&#9670;&#160;</a></span>LveDevice() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lve::LveDevice::LveDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_window_module.html">WindowModule</a> *</td>          <td class="paramname"><span class="paramname"><em>_windowModule</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructeur de la classe <a class="el" href="classlve_1_1_lve_device.html" title="Classe représentant un périphérique Vulkan.">LveDevice</a>. </p>
<p>Initialise un périphérique Vulkan en prenant une référence à une fenêtre Vulkan <a class="el" href="classlve_1_1_lve_window.html">LveWindow</a> en tant que paramètre.</p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">_windowModule</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3928e5409dc9c8e054d06270a56c9d93" name="a3928e5409dc9c8e054d06270a56c9d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3928e5409dc9c8e054d06270a56c9d93">&#9670;&#160;</a></span>~LveDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">lve::LveDevice::~LveDevice </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructeur de la classe <a class="el" href="classlve_1_1_lve_device.html" title="Classe représentant un périphérique Vulkan.">LveDevice</a>. </p>
<p>Nettoie les ressources associées au périphérique Vulkan lorsqu'il est détruit. </p>

</div>
</div>
<a id="acd0d35625590c8930b8045383c06a495" name="acd0d35625590c8930b8045383c06a495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0d35625590c8930b8045383c06a495">&#9670;&#160;</a></span>LveDevice() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lve::LveDevice::LveDevice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlve_1_1_lve_device.html">LveDevice</a> &amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructeur de copie supprimé. </p>
<p>Empêche la création d'une nouvelle instance de <a class="el" href="classlve_1_1_lve_device.html" title="Classe représentant un périphérique Vulkan.">LveDevice</a> en copiant une instance existante. </p>

</div>
</div>
<a id="a2ec8815791e048ac42a73fcbfe1b154a" name="a2ec8815791e048ac42a73fcbfe1b154a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec8815791e048ac42a73fcbfe1b154a">&#9670;&#160;</a></span>LveDevice() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lve::LveDevice::LveDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlve_1_1_lve_device.html">LveDevice</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructeur de déplacement supprimé. </p>
<p>Empêche la création d'une nouvelle instance de <a class="el" href="classlve_1_1_lve_device.html" title="Classe représentant un périphérique Vulkan.">LveDevice</a> en déplaçant une instance existante. </p>

</div>
</div>
<h2 class="groupheader">Documentation des fonctions membres</h2>
<a id="a70cb21509496085180d25539f12c6e0f" name="a70cb21509496085180d25539f12c6e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cb21509496085180d25539f12c6e0f">&#9670;&#160;</a></span>BeginSingleTimeCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vk::CommandBuffer lve::LveDevice::BeginSingleTimeCommands </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Démarre une séquence de commandes Vulkan temporaires. </p>
<p>Démarre une série de commandes Vulkan pour une utilisation unique.</p>
<p>Cette fonction alloue un tampon de commandes Vulkan et le démarre pour une utilisation unique.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Le tampon de commandes Vulkan alloué.</dd></dl>
<p>Cette fonction alloue et démarre un tampon de commandes Vulkan pour une utilisation unique. Le tampon de commandes retourné peut être utilisé pour exécuter des commandes Vulkan qui doivent être exécutées une seule fois.</p>
<dl class="section return"><dt>Renvoie</dt><dd>Le tampon de commandes Vulkan alloué et démarré. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>en cas d'échec de l'allocation du tampon de commandes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15e53a2d80e60f69d69882e65429924b" name="a15e53a2d80e60f69d69882e65429924b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e53a2d80e60f69d69882e65429924b">&#9670;&#160;</a></span>CopyBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lve::LveDevice::CopyBuffer </td>
          <td>(</td>
          <td class="paramtype">vk::Buffer</td>          <td class="paramname"><span class="paramname"><em>_srcBuffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::Buffer</td>          <td class="paramname"><span class="paramname"><em>_dstBuffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::DeviceSize</td>          <td class="paramname"><span class="paramname"><em>_size</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copie les données d'un tampon source vers un tampon de destination. </p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">_srcBuffer</td><td>Le tampon source à partir duquel copier les données. </td></tr>
    <tr><td class="paramname">_dstBuffer</td><td>Le tampon de destination où copier les données. </td></tr>
    <tr><td class="paramname">_size</td><td>La taille des données à copier.</td></tr>
  </table>
  </dd>
</dl>
<p>Cette fonction utilise un tampon de commandes temporaire pour copier les données du tampon source vers le tampon de destination. Elle garantit que l'opération de copie se produit de manière synchrone, c'est-à-dire que le tampon de commandes temporaire est soumis à la file de commandes graphiques, attend que toutes les opérations en cours sur cette file soient terminées, puis est libéré.</p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">_srcBuffer</td><td>Le tampon source à partir duquel copier les données. </td></tr>
    <tr><td class="paramname">_dstBuffer</td><td>Le tampon de destination vers lequel copier les données. </td></tr>
    <tr><td class="paramname">_size</td><td>La taille des données à copier, en octets. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>en cas d'échec de l'allocation ou de l'enregistrement des commandes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada99e3ebd5a9f7b3df3840e97fa91f78" name="ada99e3ebd5a9f7b3df3840e97fa91f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada99e3ebd5a9f7b3df3840e97fa91f78">&#9670;&#160;</a></span>CopyBufferToImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lve::LveDevice::CopyBufferToImage </td>
          <td>(</td>
          <td class="paramtype">vk::Buffer</td>          <td class="paramname"><span class="paramname"><em>_buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::Image</td>          <td class="paramname"><span class="paramname"><em>_image</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>_width</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>_height</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>_layerCount</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copie les données d'un tampon vers une image Vulkan. </p>
<p>Cette fonction copie les données d'un tampon Vulkan vers une image Vulkan en spécifiant la largeur, la hauteur et le nombre de couches de l'image.</p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">_buffer</td><td>Le tampon contenant les données à copier. </td></tr>
    <tr><td class="paramname">_image</td><td>L'image Vulkan de destination. </td></tr>
    <tr><td class="paramname">_width</td><td>La largeur de l'image. </td></tr>
    <tr><td class="paramname">_height</td><td>La hauteur de l'image. </td></tr>
    <tr><td class="paramname">_layerCount</td><td>Le nombre de couches de l'image.</td></tr>
  </table>
  </dd>
</dl>
<p>Cette fonction utilise un tampon de commandes temporaire pour copier les données du tampon vers l'image Vulkan. Elle garantit que l'opération de copie se produit de manière synchrone, c'est-à-dire que le tampon de commandes temporaire est soumis à la file de commandes graphiques, attend que toutes les opérations en cours sur cette file soient terminées, puis est libéré.</p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">_buffer</td><td>Le tampon contenant les données à copier vers l'image. </td></tr>
    <tr><td class="paramname">_image</td><td>L'image Vulkan de destination vers laquelle copier les données. </td></tr>
    <tr><td class="paramname">_width</td><td>La largeur de l'image en pixels. </td></tr>
    <tr><td class="paramname">_height</td><td>La hauteur de l'image en pixels. </td></tr>
    <tr><td class="paramname">_layerCount</td><td>Le nombre de couches de l'image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>en cas d'échec de l'allocation ou de l'enregistrement des commandes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a170e75725fcef0f1c461651a139bb8ce" name="a170e75725fcef0f1c461651a139bb8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a170e75725fcef0f1c461651a139bb8ce">&#9670;&#160;</a></span>CreateBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lve::LveDevice::CreateBuffer </td>
          <td>(</td>
          <td class="paramtype">vk::DeviceSize</td>          <td class="paramname"><span class="paramname"><em>_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::BufferUsageFlags</td>          <td class="paramname"><span class="paramname"><em>_usage</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::MemoryPropertyFlags</td>          <td class="paramname"><span class="paramname"><em>_properties</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::Buffer &amp;</td>          <td class="paramname"><span class="paramname"><em>_buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::DeviceMemory &amp;</td>          <td class="paramname"><span class="paramname"><em>_bufferMemory</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crée un tampon Vulkan avec les paramètres spécifiés. </p>
<p>Crée un tampon Vulkan avec la taille, l'utilisation et les propriétés spécifiées.</p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">_size</td><td>La taille du tampon. </td></tr>
    <tr><td class="paramname">_usage</td><td>Les indicateurs d'utilisation du tampon. </td></tr>
    <tr><td class="paramname">_properties</td><td>Les propriétés de la mémoire du tampon. </td></tr>
    <tr><td class="paramname">_buffer</td><td>Référence à l'objet tampon Vulkan créé. </td></tr>
    <tr><td class="paramname">_bufferMemory</td><td>Référence à l'objet mémoire du tampon Vulkan créé.</td></tr>
  </table>
  </dd>
</dl>
<p>Cette fonction crée un tampon Vulkan avec la taille, l'utilisation et les propriétés spécifiées, et associe la mémoire appropriée au tampon.</p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">_size</td><td>La taille du tampon en octets. </td></tr>
    <tr><td class="paramname">_usage</td><td>Les indicateurs d'utilisation du tampon. </td></tr>
    <tr><td class="paramname">_properties</td><td>Les propriétés de mémoire du tampon. </td></tr>
    <tr><td class="paramname">_buffer</td><td>Une référence à l'objet tampon à créer. </td></tr>
    <tr><td class="paramname">_bufferMemory</td><td>Une référence à la mémoire allouée pour le tampon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>en cas d'échec de la création ou de l'allocation de mémoire pour le tampon. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0556bd5de6d7e04cd817ce000c64f1d" name="af0556bd5de6d7e04cd817ce000c64f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0556bd5de6d7e04cd817ce000c64f1d">&#9670;&#160;</a></span>CreateImageWithInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lve::LveDevice::CreateImageWithInfo </td>
          <td>(</td>
          <td class="paramtype">const vk::ImageCreateInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>_imageInfo</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::MemoryPropertyFlags</td>          <td class="paramname"><span class="paramname"><em>_properties</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::Image &amp;</td>          <td class="paramname"><span class="paramname"><em>_image</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::DeviceMemory &amp;</td>          <td class="paramname"><span class="paramname"><em>_imageMemory</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crée une image Vulkan avec les informations fournies. </p>
<p>Crée une image Vulkan avec les informations spécifiées.</p>
<p>Cette fonction crée une image Vulkan en utilisant les informations spécifiées dans la structure VkImageCreateInfo.</p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">_imageInfo</td><td>Les informations de création de l'image. </td></tr>
    <tr><td class="paramname">_properties</td><td>Les propriétés de la mémoire de l'image. </td></tr>
    <tr><td class="paramname">_image</td><td>Référence à l'objet image Vulkan créé. </td></tr>
    <tr><td class="paramname">_imageMemory</td><td>Référence à l'objet mémoire de l'image Vulkan créé.</td></tr>
  </table>
  </dd>
</dl>
<p>Cette fonction crée une image Vulkan en utilisant les informations fournies dans l'objet VkImageCreateInfo. Elle alloue également la mémoire nécessaire pour cette image et associe cette mémoire à l'image créée.</p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">_imageInfo</td><td>Les informations nécessaires à la création de l'image. </td></tr>
    <tr><td class="paramname">_properties</td><td>Les propriétés de la mémoire de l'image. </td></tr>
    <tr><td class="paramname">_image</td><td>Référence où l'objet image créé sera stocké. </td></tr>
    <tr><td class="paramname">_imageMemory</td><td>Référence où la mémoire de l'image sera stockée. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>en cas d'échec de la création de l'image ou de l'allocation de mémoire. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11d82b4686e1e0ca2e3ca7143fd56865" name="a11d82b4686e1e0ca2e3ca7143fd56865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d82b4686e1e0ca2e3ca7143fd56865">&#9670;&#160;</a></span>CreateInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vk::Instance lve::LveDevice::CreateInstance </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crée une instance Vulkan. </p>
<p>Crée une instance Vulkan pour l'application.</p>
<p>Cette fonction initialise une instance Vulkan, qui représente la connexion entre l'application et l'API Vulkan.</p>
<p>Cette fonction configure et crée une instance Vulkan, qui est la première étape dans l'utilisation de l'API Vulkan. Elle configure les informations d'application, les extensions requises, les couches de validation, et crée l'instance Vulkan correspondante.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>si la création de l'instance échoue ou si les couches de validation sont activées mais non disponibles. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4755528cbaa93add122a7edbf464845" name="ab4755528cbaa93add122a7edbf464845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4755528cbaa93add122a7edbf464845">&#9670;&#160;</a></span>Device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::Device lve::LveDevice::Device </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Récupère l'objet de périphérique Vulkan. </p>
<dl class="section return"><dt>Renvoie</dt><dd>L'objet de périphérique Vulkan. </dd></dl>

</div>
</div>
<a id="a1e3f80b67ef6cbd66e48490e5396fd13" name="a1e3f80b67ef6cbd66e48490e5396fd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3f80b67ef6cbd66e48490e5396fd13">&#9670;&#160;</a></span>EndSingleTimeCommands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lve::LveDevice::EndSingleTimeCommands </td>
          <td>(</td>
          <td class="paramtype">vk::CommandBuffer</td>          <td class="paramname"><span class="paramname"><em>_commandBuffer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Termine une séquence de commandes Vulkan temporaires. </p>
<p>Termine une série de commandes Vulkan pour une utilisation unique.</p>
<p>Cette fonction termine l'exécution d'une séquence de commandes Vulkan temporaires et libère les ressources associées.</p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">_commandBuffer</td><td>Le tampon de commandes Vulkan à terminer.</td></tr>
  </table>
  </dd>
</dl>
<p>Cette fonction termine l'enregistrement des commandes dans le tampon de commandes spécifié, soumet les commandes à la file de commandes graphiques pour exécution, attend la fin de l'exécution des commandes, puis libère le tampon de commandes.</p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">_commandBuffer</td><td>Le tampon de commandes Vulkan à terminer et à soumettre. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>en cas d'échec de soumission des commandes ou d'attente de la fin de l'exécution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84495cbcca8e67db53fc15d6ab5a6847" name="a84495cbcca8e67db53fc15d6ab5a6847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84495cbcca8e67db53fc15d6ab5a6847">&#9670;&#160;</a></span>FindMemoryType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lve::LveDevice::FindMemoryType </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>_typeFilter</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::MemoryPropertyFlags</td>          <td class="paramname"><span class="paramname"><em>_properties</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trouve un type de mémoire approprié pour une utilisation spécifiée. </p>
<p>Recherche un type de mémoire adapté pour les allocations de mémoire graphique.</p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">_typeFilter</td><td>Le type de filtre de mémoire. </td></tr>
    <tr><td class="paramname">_properties</td><td>Les propriétés de la mémoire. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Le type de mémoire approprié.</dd></dl>
<p>Cette fonction recherche un type de mémoire adapté pour les allocations de mémoire graphique, en tenant compte du filtre de type spécifié et des propriétés de mémoire requises.</p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">_typeFilter</td><td>Le filtre de type de mémoire spécifié. </td></tr>
    <tr><td class="paramname">_properties</td><td>Les propriétés de mémoire requises. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>L'index du type de mémoire adapté trouvé. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>si aucun type de mémoire adapté n'est trouvé. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1b015567e250ee4f37aac78a940620a" name="aa1b015567e250ee4f37aac78a940620a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b015567e250ee4f37aac78a940620a">&#9670;&#160;</a></span>FindPhysicalQueueFamilies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlve_1_1_queue_family_indices.html">QueueFamilyIndices</a> lve::LveDevice::FindPhysicalQueueFamilies </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trouve les familles de files de commandes physiques disponibles sur le périphérique. </p>
<dl class="section return"><dt>Renvoie</dt><dd>Les familles de files de commandes physiques disponibles sur le périphérique. </dd></dl>

</div>
</div>
<a id="a20a393668b4b4c5aa202ea41168dc16e" name="a20a393668b4b4c5aa202ea41168dc16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a393668b4b4c5aa202ea41168dc16e">&#9670;&#160;</a></span>FindSupportedFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vk::Format lve::LveDevice::FindSupportedFormat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; vk::Format &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>_candidates</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::ImageTiling</td>          <td class="paramname"><span class="paramname"><em>_tiling</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::FormatFeatureFlags</td>          <td class="paramname"><span class="paramname"><em>_features</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trouve un format d'image supporté par le périphérique. </p>
<p>Recherche un format d'image supporté parmi une liste de formats candidats.</p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">_candidates</td><td>Les formats d'image candidats. </td></tr>
    <tr><td class="paramname">_tiling</td><td>L'inclinaison de l'image. </td></tr>
    <tr><td class="paramname">_features</td><td>Les fonctionnalités du format de l'image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Le format d'image supporté par le périphérique.</dd></dl>
<p>Cette fonction recherche un format d'image supporté parmi une liste de formats candidats, en tenant compte du mode de tiling spécifié (linéaire ou optimal) et des fonctionnalités requises.</p>
<dl class="params"><dt>ParamÃ¨tres</dt><dd>
  <table class="params">
    <tr><td class="paramname">_candidates</td><td>La liste des formats candidats à vérifier. </td></tr>
    <tr><td class="paramname">_tiling</td><td>Le mode de tiling de l'image (VK_IMAGE_TILING_LINEAR ou VK_IMAGE_TILING_OPTIMAL). </td></tr>
    <tr><td class="paramname">_features</td><td>Les fonctionnalités requises pour le format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Le format d'image supporté trouvé. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>si aucun format d'image supporté n'est trouvé. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34aae465d220806aacc3322242696d1d" name="a34aae465d220806aacc3322242696d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34aae465d220806aacc3322242696d1d">&#9670;&#160;</a></span>GetCommandPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::CommandPool lve::LveDevice::GetCommandPool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Récupère le pool de commandes Vulkan associé au périphérique. </p>
<dl class="section return"><dt>Renvoie</dt><dd>Le pool de commandes Vulkan associé au périphérique. </dd></dl>

</div>
</div>
<a id="a705e5ae87f7a4885b8f4a115694076a5" name="a705e5ae87f7a4885b8f4a115694076a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705e5ae87f7a4885b8f4a115694076a5">&#9670;&#160;</a></span>GetSwapChainSupport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlve_1_1_swap_chain_support_details.html">SwapChainSupportDetails</a> lve::LveDevice::GetSwapChainSupport </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Récupère les détails de prise en charge de la chaîne de balisage pour le périphérique. </p>
<dl class="section return"><dt>Renvoie</dt><dd>Les détails de prise en charge de la chaîne de balisage pour le périphérique. </dd></dl>

</div>
</div>
<a id="a3db7cac38a972c8794d8cb209a784231" name="a3db7cac38a972c8794d8cb209a784231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db7cac38a972c8794d8cb209a784231">&#9670;&#160;</a></span>GraphicsQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::Queue lve::LveDevice::GraphicsQueue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Récupère la file de commandes graphiques du périphérique. </p>
<dl class="section return"><dt>Renvoie</dt><dd>La file de commandes graphiques du périphérique. </dd></dl>

</div>
</div>
<a id="aab611df790f3cc5fc5719d2d90578ecf" name="aab611df790f3cc5fc5719d2d90578ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab611df790f3cc5fc5719d2d90578ecf">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlve_1_1_lve_device.html">LveDevice</a> &amp; lve::LveDevice::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlve_1_1_lve_device.html">LveDevice</a> &amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opérateur d'affectation de copie supprimé. </p>
<p>Empêche la copie des membres d'une instance de <a class="el" href="classlve_1_1_lve_device.html" title="Classe représentant un périphérique Vulkan.">LveDevice</a> vers une autre instance existante. </p>

</div>
</div>
<a id="a0a7c2ce480c9381910528bb05ef68f70" name="a0a7c2ce480c9381910528bb05ef68f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7c2ce480c9381910528bb05ef68f70">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlve_1_1_lve_device.html">LveDevice</a> &amp; lve::LveDevice::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlve_1_1_lve_device.html">LveDevice</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opérateur d'affectation de déplacement supprimé. </p>
<p>Empêche le déplacement des membres d'une instance de <a class="el" href="classlve_1_1_lve_device.html" title="Classe représentant un périphérique Vulkan.">LveDevice</a> vers une autre instance existante. </p>

</div>
</div>
<a id="a880570c94a1582853d2301af3c88e104" name="a880570c94a1582853d2301af3c88e104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880570c94a1582853d2301af3c88e104">&#9670;&#160;</a></span>PresentQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::Queue lve::LveDevice::PresentQueue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Récupère la file de commandes de présentation du périphérique. </p>
<dl class="section return"><dt>Renvoie</dt><dd>La file de commandes de présentation du périphérique. </dd></dl>

</div>
</div>
<a id="a5c8aa1272efa148228a786f43eee2605" name="a5c8aa1272efa148228a786f43eee2605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8aa1272efa148228a786f43eee2605">&#9670;&#160;</a></span>SetupDebugMessenger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vk::DebugUtilsMessengerEXT lve::LveDevice::SetupDebugMessenger </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure le gestionnaire de débogage. </p>
<p>Configure le gestionnaire de débogage Vulkan.</p>
<p>Cette fonction configure un gestionnaire de débogage Vulkan pour recevoir les messages de validation et de débogage de l'API Vulkan.</p>
<p>Cette fonction configure le gestionnaire de débogage Vulkan si les couches de validation sont activées.</p>
<p>Elle utilise la fonction populateDebugMessengerCreateInfo() pour remplir les informations nécessaires pour la création du gestionnaire de débogage.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>si la configuration du gestionnaire de débogage échoue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e39fcb2417fc88244a2bd7b47fda216" name="a4e39fcb2417fc88244a2bd7b47fda216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e39fcb2417fc88244a2bd7b47fda216">&#9670;&#160;</a></span>Surface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vk::SurfaceKHR lve::LveDevice::Surface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Récupère la surface Vulkan associée au périphérique. </p>
<dl class="section return"><dt>Renvoie</dt><dd>La surface Vulkan associée au périphérique. </dd></dl>

</div>
</div>
<h2 class="groupheader">Documentation des donnÃ©es membres</h2>
<a id="a1ee7068dc3c270e771cf87b14da36bff" name="a1ee7068dc3c270e771cf87b14da36bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee7068dc3c270e771cf87b14da36bff">&#9670;&#160;</a></span>properties</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vk::PhysicalDeviceProperties lve::LveDevice::properties</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propriétés du périphérique physique Vulkan associé. </p>
<p>Cette structure contient les propriétés du périphérique physique Vulkan associé. </p>

</div>
</div>
<hr/>La documentation de cette classe a Ã©tÃ© gÃ©nÃ©rÃ©e Ã  partir des fichiers suivants :<ul>
<li>includes/LveEngine/<a class="el" href="lve__device_8h_source.html">lve_device.h</a></li>
<li>sources/LveEngine/<b>lve_device.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
GÃ©nÃ©rÃ© par&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
